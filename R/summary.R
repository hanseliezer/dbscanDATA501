#' Summary method for DBSCAN
#' 
#' @description
#' Prints summary statistics for clusters generated by `dbscan`.
#' 
#' @param object Object of class `dbscanDATA501`.
#' @param ... Further arguments passed to or from other methods.
#' 
#' @details
#' There are three sections to the summary:
#' * Parameters used in algorithm fitting.
#' * Clustering results: total fitting time in seconds and number of clusters generated (excluding noise).
#' * Clustering quality: results of four internal validation metrics, and a description of what should
#' be aimed for in terms of value:
#'    * Connectivity
#'    * Mean silhouette width
#'    * Dunn index
#'    * CDbw ("composed density between and within clusters")
#'    
#' 
#' 
#' ## On quality metrics
#' 
#' Care must be taken in using connectivity, mean silhouette width and Dunn index metrics to assess the
#' quality of clusters generated by density-based clustering. These metrics have an underlying assumption
#' that the generated clusters are approximately globular in shape, whereas density-based algorithms such as
#' DBSCAN are capable of generating arbitrarily-shaped clusters (Moulavi et al. 2014). Only CDbw out of these
#' four metrics has specifically been designed for density-based clusters. And unfortunately, due to the
#' underlying function's limitations, CDbw would only be defined if the original clustering's distance metric
#' is `euclidean`.
#' 
#' @references
#' Moulavi, Davoud, Pablo A. Jaskowiak, Ricardo JGB Campello, Arthur Zimek, and JÃ¶rg Sander. 2014.
#' "Density-based clustering validation." In *Proceedings of the 2014 SIAM international conference on
#' data mining*, pp. 839-847. Society for Industrial and Applied Mathematics.
#' 
#' @keywords clustering
#' @examples
#' \dontrun{
#' data(blobs)
#' dbs <- dbscan(blobs, eps=0.2, min_pts=5)
#' summary(dbs)
#' }
#' @rdname summary
#' @export
summary.dbscanDATA501 <- function(object, ...) {
  clust_nums <- object$cluster_labs[object$cluster_labs != 0]
  n_clusters <- if (length(unique(clust_nums)) > 0) length(unique(clust_nums)) else 0
  
  score_conn <- connectivity_wrapper(object$dataset, object$cluster_labs, object$metric)
  score_silh <- silhouette_wrapper(object$dataset, object$cluster_labs, object$metric)
  score_dunn <- dunn_wrapper(object$dataset, object$cluster_labs, object$metric)
  score_cdbw <- cdbw_wrapper(object$dataset, object$cluster_labs, object$metric)
  
  print_list <- list('min_pts'=object$min_pts,
                     'eps'=object$eps,
                     'metric'=object$metric,
                     'normalise'=object$normalise,
                     'border_pts'=object$border_pts,
                     'fitting_time'=object$fitting_time,
                     'n_clusters'=n_clusters,
                     'score_conn'=score_conn,
                     'score_silh'=score_silh,
                     'score_dunn'=score_dunn,
                     'score_cdbw'=score_cdbw)
  print_list_obj <- structure(print_list,
                              class='summary.dbscanDATA501')
  
  print(print_list_obj, ...)
  
}

print.summary.dbscanDATA501 <-function(object, ...) {
  cat("DBSCAN result summary:\n\n")
  
  cat("Parameters:\n")
  cat("eps:", object$eps, "\n")
  cat("min_pts:", object$min_pts, "\n")
  cat("metric:", object$metric, "\n")
  cat("normalise:", object$normalise, "\n")
  cat(paste0("border_pts: ", object$border_pts, "\n\n"))
  
  cat("Running time (s):", round(object$fitting_time, 5), "\n")
  cat(paste0("Number of generated clusters (excl. noise): ", object$n_clusters, "\n\n"))
  
  cat("Clustering quality metrics:\n")
  cat("Connectivity (lower better):", round(object$score_conn, 5), "\n")
  cat("Mean silhouette width (nearer to 1 better):", round(object$score_silh, 5), "\n")
  cat("Dunn index (higher better):", round(object$score_dunn, 5), "\n")
  cat(paste0("CDbw (higher better): ", round(object$score_cdbw, 5), "\n\n"))
  cat("NOTE:\n")
  cat("- Caution must be taken when interpreting connectivity, mean silhouette width and Dunn index for non-globular clusters.\n")
  cat("- Due to the underlying function's limitation, CDbw is only defined when 'metric = euclidean'.")
}

##############################################################################

# helper functions
# need to supply 'metric' argument as the calculation of these scores are different
# depending whether it is done on a dataset or distance matrix
# tryCatch functions to prevent possible errors originating from the score functions (as a result
# from weird clustering results) from stopping summary() altogether. in case of any errors/warnings,
# return NaN
connectivity_wrapper <- function(data, labs, metric) {
  if (metric == 'precomputed') {
    score <- tryCatch(clValid::connectivity(distance=data, clusters=labs),
                      error=function(e) { return(NaN) },
                      warning=function(w) { return(NaN) })
  } else {
    score <- tryCatch(clValid::connectivity(Data=data, clusters=labs),
                      error=function(e) { return(NaN) },
                      warning=function(w) { return(NaN) })
  }
  
  return(score)
}

silhouette_wrapper <- function(data, labs, metric) {
  dist_mat <- if (metric == 'precomputed') data else dist(data)
  silh <- tryCatch(cluster::silhouette(x=labs, dist=dist_mat),
                   error=function(e) { return(NaN) },
                   warning=function(w) { return(NaN) })
  
  # silhouette returns NA for 'trivial clustering' (either only 1 or all N clusters)
  # else it will return a list, so check length of returned object
  score <- if (length(silh) > 1) mean(silh[, 'sil_width']) else NaN
  return(score)
}

dunn_wrapper <- function(data, labs, metric) {
  if (metric == 'precomputed') {
    score <- tryCatch(clValid::dunn(distance=data, clusters=labs),
                      error=function(e) { return(NaN) },
                      warning=function(w) { return(NaN) })
  } else {
    score <- tryCatch(clValid::dunn(Data=data, clusters=labs),
                      error=function(e) { return(NaN) },
                      warning=function(w) { return(NaN) })
  }
  
  return(score)
}

cdbw_wrapper <- function(data, labs, metric) {
  if (metric == 'euclidean') {
    score <- tryCatch(fpc::cdbw(x=data, clustering=labs)$cdbw,
                      error=function(e) { return(NaN) },
                      warning=function(w) { return(NaN) })
  } else {
    score <- NaN
  }

  return(score)
}
